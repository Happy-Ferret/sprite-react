{"remainingRequest":"/Users/akirawu/Workspace/spritejs/sprite-react/node_modules/babel-loader/lib/index.js?{\"presets\":[[\"@babel/preset-env\",{\"targets\":{\"browsers\":[\"> 1%\",\"last 2 versions\",\"not ie <= 8\"]}}],\"@babel/preset-react\",[\"/Users/akirawu/Workspace/spritejs/sprite-react/node_modules/babel-preset-docz/dist/index.js\",{\"flow\":true,\"typescript\":false,\"parseProps\":true}]],\"plugins\":[\"@babel/plugin-transform-runtime\",\"@babel/plugin-syntax-dynamic-import\",\"@babel/plugin-syntax-import-meta\",\"@babel/plugin-proposal-class-properties\",\"@babel/plugin-proposal-json-strings\",[\"@babel/plugin-proposal-decorators\",{\"legacy\":true}],\"@babel/plugin-proposal-function-sent\",\"@babel/plugin-proposal-export-namespace-from\",\"@babel/plugin-proposal-numeric-separator\",\"@babel/plugin-proposal-throw-expressions\",\"/Users/akirawu/Workspace/spritejs/sprite-react/node_modules/react-hot-loader/babel.js\"],\"cacheDirectory\":true,\"babelrc\":false}!/Users/akirawu/Workspace/spritejs/sprite-react/src/ReactDOMFrameScheduling.js","dependencies":[{"path":"/Users/akirawu/Workspace/spritejs/sprite-react/src/ReactDOMFrameScheduling.js","mtime":1537166343819},{"path":"/Users/akirawu/Workspace/spritejs/sprite-react/node_modules/cache-loader/dist/cjs.js","mtime":1537175402674},{"path":"/Users/akirawu/Workspace/spritejs/sprite-react/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import _typeof from \"@babel/runtime/helpers/typeof\";\n\n(function () {\n  var enterModule = require('react-hot-loader').enterModule;\n\n  enterModule && enterModule(module);\n})();\n\n// adapted FROM: https://github.com/facebook/react/blob/3019210df2b486416ed94d7b9becffaf254e81c4/src/renderers/shared/ReactDOMFrameScheduling.js\n// This is a built-in polyfill for requestIdleCallback. It works by scheduling\n// a requestAnimationFrame, storing the time for the start of the frame, then\n// scheduling a postMessage which gets scheduled after paint. Within the\n// postMessage handler do as much work as possible until time + frame rate.\n// By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\n\nvar hasNativePerformanceNow = (typeof performance === \"undefined\" ? \"undefined\" : _typeof(performance)) === 'object' && typeof performance.now === 'function';\nvar now;\n\nif (hasNativePerformanceNow) {\n  now = function now() {\n    return performance.now();\n  };\n} else {\n  now = function now() {\n    return Date.now();\n  };\n} // TODO: There's no way to cancel, because Fiber doesn't atm.\n\n\nvar rIC;\n\nif (!ExecutionEnvironment.canUseDOM) {\n  rIC = function rIC(frameCallback) {\n    setTimeout(function () {\n      frameCallback({\n        timeRemaining: function timeRemaining() {\n          return Infinity;\n        }\n      });\n    });\n    return 0;\n  };\n} else if (typeof requestIdleCallback !== 'function') {\n  // Polyfill requestIdleCallback.\n  var scheduledRAFCallback = null;\n  var scheduledRICCallback = null;\n  var isIdleScheduled = false;\n  var isAnimationFrameScheduled = false;\n  var frameDeadline = 0; // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n  var frameDeadlineObject;\n\n  if (hasNativePerformanceNow) {\n    frameDeadlineObject = {\n      timeRemaining: function timeRemaining() {\n        // We assume that if we have a performance timer that the rAF callback\n        // gets a performance timer value. Not sure if this is always true.\n        return frameDeadline - performance.now();\n      }\n    };\n  } else {\n    frameDeadlineObject = {\n      timeRemaining: function timeRemaining() {\n        // Fallback to Date.now()\n        return frameDeadline - Date.now();\n      }\n    };\n  } // We use the postMessage trick to defer idle work until after the repaint.\n\n\n  var messageKey = \"__reactIdleCallback$\".concat(Math.random().toString(36).slice(2));\n\n  var idleTick = function idleTick(event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n\n    isIdleScheduled = false;\n    var callback = scheduledRICCallback;\n    scheduledRICCallback = null;\n\n    if (callback !== null) {\n      callback(frameDeadlineObject);\n    }\n  }; // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n\n\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function animationTick(rafTime) {\n    isAnimationFrameScheduled = false;\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If we get lower than that, it is probably a bug.\n        nextFrameTime = 8;\n      } // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n\n\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n\n    frameDeadline = rafTime + activeFrameTime;\n\n    if (!isIdleScheduled) {\n      isIdleScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n\n    var callback = scheduledRAFCallback;\n    scheduledRAFCallback = null;\n\n    if (callback !== null) {\n      callback(rafTime);\n    }\n  };\n\n  rIC = function rIC(callback) {\n    // This assumes that we only schedule one callback at a time because that's\n    // how Fiber uses it.\n    scheduledRICCallback = callback;\n\n    if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrame(animationTick);\n    }\n\n    return 0;\n  };\n} else {\n  rIC = requestIdleCallback;\n}\n\nexport { now, rIC };\n;\n\n(function () {\n  var reactHotLoader = require('react-hot-loader').default;\n\n  var leaveModule = require('react-hot-loader').leaveModule;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(hasNativePerformanceNow, \"hasNativePerformanceNow\", \"/Users/akirawu/Workspace/spritejs/sprite-react/src/ReactDOMFrameScheduling.js\");\n  reactHotLoader.register(now, \"now\", \"/Users/akirawu/Workspace/spritejs/sprite-react/src/ReactDOMFrameScheduling.js\");\n  reactHotLoader.register(rIC, \"rIC\", \"/Users/akirawu/Workspace/spritejs/sprite-react/src/ReactDOMFrameScheduling.js\");\n  leaveModule(module);\n})();\n\n;",{"version":3,"sources":["/Users/akirawu/Workspace/spritejs/sprite-react/src/ReactDOMFrameScheduling.js"],"names":["ExecutionEnvironment","require","hasNativePerformanceNow","performance","now","Date","rIC","canUseDOM","frameCallback","setTimeout","timeRemaining","Infinity","requestIdleCallback","scheduledRAFCallback","scheduledRICCallback","isIdleScheduled","isAnimationFrameScheduled","frameDeadline","previousFrameTime","activeFrameTime","frameDeadlineObject","messageKey","Math","random","toString","slice","idleTick","event","source","window","data","callback","addEventListener","animationTick","rafTime","nextFrameTime","postMessage","requestAnimationFrame"],"mappings":"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","sourcesContent":["// adapted FROM: https://github.com/facebook/react/blob/3019210df2b486416ed94d7b9becffaf254e81c4/src/renderers/shared/ReactDOMFrameScheduling.js\n\n\n// This is a built-in polyfill for requestIdleCallback. It works by scheduling\n// a requestAnimationFrame, storing the time for the start of the frame, then\n// scheduling a postMessage which gets scheduled after paint. Within the\n// postMessage handler do as much work as possible until time + frame rate.\n// By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\nconst ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\n\nconst hasNativePerformanceNow\n  = typeof performance === 'object' && typeof performance.now === 'function';\n\nlet now;\nif(hasNativePerformanceNow) {\n  now = function () {\n    return performance.now();\n  };\n} else {\n  now = function () {\n    return Date.now();\n  };\n}\n\n// TODO: There's no way to cancel, because Fiber doesn't atm.\nlet rIC;\n\nif(!ExecutionEnvironment.canUseDOM) {\n  rIC = function (frameCallback) {\n    setTimeout(() => {\n      frameCallback({\n        timeRemaining() {\n          return Infinity;\n        },\n      });\n    });\n    return 0;\n  };\n} else if(typeof requestIdleCallback !== 'function') {\n  // Polyfill requestIdleCallback.\n\n  let scheduledRAFCallback = null;\n  let scheduledRICCallback = null;\n\n  let isIdleScheduled = false;\n  let isAnimationFrameScheduled = false;\n\n  let frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  let previousFrameTime = 33;\n  let activeFrameTime = 33;\n\n  let frameDeadlineObject;\n  if(hasNativePerformanceNow) {\n    frameDeadlineObject = {\n      timeRemaining() {\n        // We assume that if we have a performance timer that the rAF callback\n        // gets a performance timer value. Not sure if this is always true.\n        return frameDeadline - performance.now();\n      },\n    };\n  } else {\n    frameDeadlineObject = {\n      timeRemaining() {\n        // Fallback to Date.now()\n        return frameDeadline - Date.now();\n      },\n    };\n  }\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  const messageKey\n    = `__reactIdleCallback$${\n      Math.random()\n        .toString(36)\n        .slice(2)}`;\n  const idleTick = function (event) {\n    if(event.source !== window || event.data !== messageKey) {\n      return;\n    }\n    isIdleScheduled = false;\n    const callback = scheduledRICCallback;\n    scheduledRICCallback = null;\n    if(callback !== null) {\n      callback(frameDeadlineObject);\n    }\n  };\n  // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n  window.addEventListener('message', idleTick, false);\n\n  const animationTick = function (rafTime) {\n    isAnimationFrameScheduled = false;\n    let nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if(\n      nextFrameTime < activeFrameTime\n      && previousFrameTime < activeFrameTime\n    ) {\n      if(nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If we get lower than that, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime\n        = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if(!isIdleScheduled) {\n      isIdleScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n    const callback = scheduledRAFCallback;\n    scheduledRAFCallback = null;\n    if(callback !== null) {\n      callback(rafTime);\n    }\n  };\n\n  rIC = function (callback) {\n    // This assumes that we only schedule one callback at a time because that's\n    // how Fiber uses it.\n    scheduledRICCallback = callback;\n    if(!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrame(animationTick);\n    }\n    return 0;\n  };\n} else {\n  rIC = requestIdleCallback;\n}\n\nexport {now, rIC};\n"]}]}